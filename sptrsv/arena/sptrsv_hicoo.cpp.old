//================================
//helloworld.cpp
//================================
//ARENA implementation of helloworld
//
//

//#define DEBUG
//#define TRACE
#include "../../lib/ARENA.h"
#include <string.h>
#include <math.h>
#include <sys/time.h>
#include "mmio_highlevel.h"
#include <HiParTI.h>
#define NODES 2

#define SOLVE 100
#define DEPENDENT 101
using namespace std;

//load matrix
/*
    int m_dev,n_dev,nnzL_dev;
    int *csrRowPtrL_dev;
    int *csrColIdxL_dev;
    double *csrValL_dev;

    double *depend_dev;
    double *x_dev;
    double *b_dev; 
    double *x_ref; 
    int start_dev; 
    int end_dev;
    int start_nnz_dev;
    int nnzL;
*/
	
    ptiSparseMatrixHiCOO himtx_dev;
    ptiValueVector x_dev, b_dev, depend_dev, x_ref;
    int startb_dev, endb_dev, total_nb, m, n, start_row_dev, end_row_dev; 
    int * block_depend;
	  ptiNnzIndex nnz_dev;
     
int local_rank;
int local_start;
int local_end;

void ptiGetLtriangular_coo(ptiSparseMatrix *mtx_L, ptiSparseMatrix *mtx){
	int nnz_counter = 0;
	ptiIndexVector rowind_tmp; /// row indices, length nnz
    ptiIndexVector colind_tmp; /// column indices, length nnz
    ptiValueVector values_tmp; /// non-zero values, length nnz

	ptiNewIndexVector(&rowind_tmp, mtx->nnz, mtx->nnz);   
    ptiNewIndexVector(&colind_tmp, mtx->nnz, mtx->nnz);
    ptiNewValueVector(&values_tmp, mtx->nnz, mtx->nnz);
    

	for (int i =0; i < mtx->nnz; i++)
	{
		if(mtx->rowind.data[i] > mtx->colind.data[i]){
			rowind_tmp.data[nnz_counter] = mtx->rowind.data[i];
			colind_tmp.data[nnz_counter] = mtx->colind.data[i];
			values_tmp.data[nnz_counter] = mtx->values.data[i];
			nnz_counter++;

		}else if (mtx->rowind.data[i]==mtx->colind.data[i]){
			rowind_tmp.data[nnz_counter] = mtx->rowind.data[i];
			colind_tmp.data[nnz_counter] = mtx->colind.data[i];
			values_tmp.data[nnz_counter] = 1.0;
			nnz_counter++;
		}
	}

	ptiNewSparseMatrix(mtx_L, mtx->nrows,  mtx->ncols, nnz_counter);
	ptiCopyIndexVector(&mtx_L->rowind, &rowind_tmp, nnz_counter);
	ptiCopyIndexVector(&mtx_L->colind, &colind_tmp, nnz_counter);
	ptiCopyValueVector(&mtx_L->values, &values_tmp, nnz_counter);

}

void ptiDistribute_coo_row(ptiSparseMatrix *mtx_dev, ptiSparseMatrix *mtx, int start, int end){
	int nnz_counter = 0;
	ptiIndexVector rowind_tmp; /// row indices, length nnz
  ptiIndexVector colind_tmp; /// column indices, length nnz
  ptiValueVector values_tmp; /// non-zero values, length nnz

	ptiNewIndexVector(&rowind_tmp, mtx->nnz, mtx->nnz);   
  ptiNewIndexVector(&colind_tmp, mtx->nnz, mtx->nnz);
  ptiNewValueVector(&values_tmp, mtx->nnz, mtx->nnz);
    

	for (int i =0; i < mtx->nnz; i++)
	{
		if((mtx->rowind.data[i] >= start)&&(mtx->rowind.data[i] < end)){
			rowind_tmp.data[nnz_counter] = mtx->rowind.data[i];
			colind_tmp.data[nnz_counter] = mtx->colind.data[i];
			values_tmp.data[nnz_counter] = mtx->values.data[i];
			nnz_counter++;
	}
 }
	ptiNewSparseMatrix(mtx_dev, mtx->nrows,  mtx->ncols, nnz_counter);
	ptiCopyIndexVector(&mtx_dev->rowind, &rowind_tmp, nnz_counter);
	ptiCopyIndexVector(&mtx_dev->colind, &colind_tmp, nnz_counter);
	ptiCopyValueVector(&mtx_dev->values, &values_tmp, nnz_counter);

}

void ptiMatrixReallocationHiCOO(ptiSparseMatrixHiCOO *himtx_dev, ptiNnzIndex nnz_dev, int start_block, int end_block, ptiSparseMatrixHiCOO *himtx){



	ptiIndex nb_dev = end_block-start_block;
	int start_nnz = himtx->bptr.data[start_block];

	ptiNnzIndexVector         bptr_tmp;      /// Block pointers to all nonzeros, nb = bptr.length - 1
    ptiBlockIndexVector       bindI_tmp;    /// Block indices for rows, length nb
    ptiBlockIndexVector       bindJ_tmp;    /// Block indices for columns, length nb
    ptiElementIndexVector     eindI_tmp;    /// Element indices within each block for rows, length nnz
    ptiElementIndexVector     eindJ_tmp;    /// Element indices within each block for columns, length nnz
    ptiValueVector            values_tmp;      /// non-zero values, length nnz
	

	ptiNewNnzIndexVector(&bptr_tmp, nb_dev+1, nb_dev+1);
	ptiNewBlockIndexVector(&bindI_tmp, nb_dev, nb_dev);
	ptiNewBlockIndexVector(&bindJ_tmp, nb_dev, nb_dev);
	ptiNewElementIndexVector(&eindI_tmp, nnz_dev, nnz_dev);
	ptiNewElementIndexVector(&eindJ_tmp, nnz_dev, nnz_dev);
	ptiNewValueVector(&values_tmp, nnz_dev, nnz_dev);

	bptr_tmp.data[0] = 0;

	for (int i = 0; i < nb_dev; i++){
		bptr_tmp.data[i+1] = himtx->bptr.data[i+1+start_block]-start_nnz;
		bindI_tmp.data[i] = himtx->bindI.data[i+start_block];
		bindJ_tmp.data[i] = himtx->bindJ.data[i+start_block];
	}

	for (int i = 0; i < nnz_dev; i++){
		eindI_tmp.data[i] = himtx->eindI.data[i+start_nnz];
		eindJ_tmp.data[i] = himtx->eindJ.data[i+start_nnz];
		values_tmp.data[i] = himtx->values.data[i+start_nnz];
	}

	ptiNewSparseMatrixHiCOO(himtx_dev, himtx->nrows, himtx->ncols, nnz_dev, himtx->sb_bits, himtx->sk_bits);


	ptiCopyNnzIndexVector(&himtx_dev->bptr, &bptr_tmp);
	ptiCopyBlockIndexVector(&himtx_dev->bindI, &bindI_tmp);
	ptiCopyBlockIndexVector(&himtx_dev->bindJ, &bindJ_tmp);
	ptiCopyElementIndexVector(&himtx_dev->eindI, &eindI_tmp);
	ptiCopyElementIndexVector(&himtx_dev->eindJ, &eindJ_tmp);
	ptiCopyValueVector(&himtx_dev->values, &values_tmp, nnz_dev);

	ptiIndex sk = (ptiIndex)pow(2, himtx->sk_bits);
    ptiIndex kernel_ndim = (himtx->nrows + sk - 1)/sk;
    himtx_dev->kschr = (ptiIndexVector*)malloc(kernel_ndim * sizeof(*(himtx->kschr)));

	 for(ptiIndex i = 0; i < kernel_ndim; ++i) {
         ptiCopyIndexVector(&(himtx_dev->kschr[i]), &(himtx->kschr[i]), himtx->nkiters);
    }

	ptiCopyNnzIndexVector(&himtx_dev->kptr, &himtx->kptr);
	himtx_dev->nkiters = himtx->nkiters;
}


int data_distribution(char  * filename)
{


	ptiSparseMatrix mtx, mtx_L, mtx_dev;
	ptiSparseMatrixHiCOO himtx;
      // load mtx data to the hicoo format

	FILE *fi = NULL;
    fi = fopen(filename, "r");
	ptiAssert(ptiLoadSparseMatrix(&mtx, 1, fi) == 0);
    fclose(fi);
    ptiRandomValueVector(&(mtx.values));    // to better compare results

	//if (ARENA_local_rank == 0) ptiSparseMatrixStatus(&mtx, stdout);

	if(mtx.nrows != mtx.ncols){
		printf("error and exit: matrix' m != n \n");
		return -1;
	}

	// Covert to L matrix
	ptiGetLtriangular_coo(&mtx_L, &mtx);
	//if (ARENA_local_rank == 0) ptiSparseMatrixStatus(&mtx_L, stdout);
    ptiFreeSparseMatrix(&mtx);
    
  // Convert to HiCOO 
	ptiNnzIndex max_nnzb = 0;
	ptiElementIndex sb_bits = 4;
	ptiElementIndex sk_bits = sb_bits;
  ptiIndex sb = (ptiIndex)pow(2, sb_bits);
  ptiAssert(ptiSparseMatrixToHiCOO(&himtx, &max_nnzb, &mtx_L, sb_bits, sk_bits) == 0);
   // if (ARENA_local_rank == 0) ptiSparseMatrixStatusHiCOO(&himtx, stdout);  
  
  // Generate x_ref, x_dev and b_dev, block depend

	ptiNewValueVector(&x_ref, himtx.ncols, himtx.ncols);   //redundent x_ref
  ptiRandomValueVector(&x_ref);                         
  ptiNewValueVector(&b_dev, himtx.nrows, himtx.nrows);   //redundent b_dev
	ptiNewValueVector(&x_dev, himtx.ncols, himtx.ncols);   //redundent x_dev
	ptiNewValueVector(&depend_dev, himtx.ncols, himtx.ncols);  //redundent x_dev
 

	printf("Run ptiSparseMatrixMulVectorHiCOO:\n");
  ptiSparseMatrixMulVectorHiCOO(&b_dev, &himtx, &x_ref); // compute b
  
  total_nb = himtx.bptr.len-1;
 

	ptiFreeSparseMatrixHiCOO(&himtx);
    
  //distribute L matrix
  m = mtx_L.nrows;
	n = mtx_L.ncols;
  
  int balance_block = ceil(ceil((double)m/sb) /NODES); //dense block size
  int balance_row = sb*balance_block;
  start_row_dev =  local_rank*balance_row;
  end_row_dev = (((local_rank+1)*balance_row) < (m)? ((local_rank+1)*balance_row) : (m));
  printf("start row %d, end row %d", start_row_dev, end_row_dev );
  ptiDistribute_coo_row(&mtx_dev, &mtx_L, start_row_dev, end_row_dev);
 // ptiSparseMatrixStatus(&mtx_dev, stdout);
  
  ptiFreeSparseMatrix(&mtx_L);
  
  
  //convert to Hicoo_dev
  ptiAssert(ptiSparseMatrixToHiCOO(&himtx_dev, &max_nnzb, &mtx_dev, sb_bits, sk_bits) == 0);
  ptiSparseMatrixStatusHiCOO(&himtx_dev, stdout);
   ptiFreeSparseMatrix(&mtx_dev);
  
  //get dev task token address: startb_dev, endb_dev // dense address space
  startb_dev = ceil(start_row_dev/sb)*ceil(n/sb);
  endb_dev = ceil(end_row_dev/sb)*ceil(n/sb);
  
   block_depend = (int *)malloc((m*n) * sizeof(int)); //setup block_dependency for each block
  for(int i = 0; i < total_nb; i++){
      block_depend[i] = 0;
  }
    
/*
	// Convert to HiCOO 
	ptiNnzIndex max_nnzb = 0;
	ptiElementIndex sb_bits = 4;
	ptiElementIndex sk_bits = sb_bits;
    ptiAssert(ptiSparseMatrixToHiCOO(&himtx, &max_nnzb, &mtx_L, sb_bits, sk_bits) == 0);
   // if (ARENA_local_rank == 0) ptiSparseMatrixStatusHiCOO(&himtx, stdout);
    ptiFreeSparseMatrix(&mtx_L);
    
	m = himtx.nrows;
	n =  himtx.ncols;
	total_nb = himtx.bptr.len-1;
  block_depend = (int *)malloc((total_nb) * sizeof(int)); //setup block_dependency for each block
  for(int i = 0; i < total_nb; i++){
      block_depend[i] = 0;
  }
    //distribute himtx to all device
	//copy local data to himtx_dev
	int balance_block = ceil(double(total_nb)/NODES);
	startb_dev = ARENA_local_rank*balance_block;
	endb_dev = (((ARENA_local_rank+1)*balance_block) < (total_nb)? ((ARENA_local_rank+1)*balance_block) : (total_nb));
	//endb_dev = endb_dev -1;

	nnz_dev = himtx.bptr.data[endb_dev] - himtx.bptr.data[startb_dev];

	ptiMatrixReallocationHiCOO(&himtx_dev, nnz_dev, startb_dev, endb_dev, &himtx);
	ptiSparseMatrixStatusHiCOO(&himtx_dev, stdout);

	// Generate x_ref, x_dev and b_dev 

	ptiNewValueVector(&x_ref, himtx.ncols, himtx.ncols);
    ptiRandomValueVector(&x_ref);
    ptiNewValueVector(&b_dev, himtx.nrows, himtx.nrows);
	ptiNewValueVector(&x_dev, himtx.ncols, himtx.ncols);
	ptiNewValueVector(&depend_dev, himtx.ncols, himtx.ncols);

	printf("Run ptiSparseMatrixMulVectorHiCOO:\n");
    ptiSparseMatrixMulVectorHiCOO(&b_dev, &himtx, &x_ref); // compute b

	ptiFreeSparseMatrixHiCOO(&himtx);
*/
    
}

void init_data( ) 
{
    
}

/*

process sptrsv for each block
start = block id
end = block id + 1 
param = block nnz id



*/


int Solve_hicoo(int start, int end, int param, bool require_data, int length) {

  
  ptiIndex local_id = start;
  ptiIndex globle_id = local_id+ ARENA_local_bound;
  
  //printf("rank %d, local_id %d, globle_id %d\n", ARENA_local_rank, local_id, globle_id);
  block_depend[globle_id]++; 
  

  ptiIndex bi = himtx_dev.bindI.data[local_id];
  ptiIndex bj = himtx_dev.bindJ.data[local_id];
  ptiIndex sb = (ptiIndex)pow(2, himtx_dev.sb_bits);
  
  //process the block if all dependency solve //root block, //solve the first column //solve the matrix multication blocks //solve the solver blocks
  if(((bi==0)&&(bj==0))||((bi==0)&&(bi>bj)&&(block_depend[globle_id]==1))||((bi!=0)&&(bi>bj)&&(block_depend[globle_id]==2))||((bi==bj)&&(block_depend[globle_id]==1))){ 
   
     ptiNnzIndex block_nnz_id = param;
     ptiNnzIndex dev_nnz_id = block_nnz_id+ himtx_dev.bptr.data[local_id];
     
     ptiNnzIndex block_end_nnz = himtx_dev.bptr.data[local_id+1];
   
     printf("rank %d , local_id %d, global_id %d block_nnz_id %d, dev_nnz_id %d, block_end_nnz %d \n", ARENA_local_rank, local_id, globle_id, block_nnz_id, dev_nnz_id, block_end_nnz );
    
        for(ptiNnzIndex j=dev_nnz_id; j < block_end_nnz; j++)
       {
   		//printf("start process nnz %d\n", j);
   
       ptiIndex row = himtx_dev.eindI.data[j]+ bi*sb;
   		ptiIndex col = himtx_dev.eindJ.data[j]+ bj*sb;
   
   		printf("rank %d, start process nnz %d, row %d, col %d\n", ARENA_local_rank, j, row, col);
       
       if(row == col){  //solve x
         printf("solve row %d, b %f, left %f, A %f \n", row, b_dev.data[row], x_dev.data[row], himtx_dev.values.data[j] );
   			block_nnz_id++;
   			
   			x_dev.data[row] = (b_dev.data[row]-x_dev.data[row])/himtx_dev.values.data[j];
   			depend_dev.data[row] = 1;
   
   			printf("row %d done\n", row);
   			 //spawn broadcast x_dev[row]
           
         ARENA_spawn_task(DEPENDENT, (ARENA_local_end+1)%(total_nb), (ARENA_local_end+1)%(total_nb)+1, row);//, row, ARENA_local_rank, row, row+1);
   			 ARENA_remote_ask_start[(ARENA_local_rank+1)%NODES] = row; //data send to next
   			 ARENA_remote_ask_end[(ARENA_local_rank+1)%NODES] = row+1;
       }else	if(row>col){ // compute leftsum
   
   			if(depend_dev.data[col] == 1)
   			{
   				printf("process row %d, nnz %d\n", row, j);
   				x_dev.data[row]+=himtx_dev.values.data[j]*x_dev.data[col];
   
   				block_nnz_id++;
   			}
      }else if (row<col){ //upper T
   			printf("error: row %d < col %d\n", row, col);
   			return -1;
   		}
     //}else if((bi==0)&&(bi>bj)&&(block_depend[globle_id]==1)){ //solve the first column
     //}else if((bi!=0)&&(bi>bj)&&(block_depend[globle_id]==2)){ //solve the matrix multication blocks
     //}else if((bi==bj)&&(block_depend[globle_id]==1)){ //solve the solver blocks
     }
   
      printf("block %d done\n", globle_id);
      
      
      
      
      //find superblock ID. TODO: direct mapping
      ptiIndex kj =0;
   
      for(ptiNnzIndex k = 0; k < himtx_dev.kschr[bi].len; k++) {
   	   if(globle_id ==  himtx_dev.kschr[bi].data[k]) {
   		   kj =k;
   		   break;
   	   }
      }
   
      //spawn ->. TODO: update leftsum x during spawn
      if(kj < himtx_dev.kschr[bi].len-1){
   	   ptiIndex spawn_block_id = himtx_dev.kschr[bi].data[kj+1];
   	   printf("spawn to row block from %d to %d.\n", globle_id, spawn_block_id );
   	   ARENA_spawn_task(SOLVE, spawn_block_id, spawn_block_id+1, 0); //cannot transmit the left_sum now, need the node ID or transmit it to local
      }
      
      
      if (globle_id ==0){
      //spawn all colum block
        printf("spawn all colum at 0:");
   	   ptiIndex sk = (ptiIndex)pow(2, himtx_dev.sk_bits);
   	   ptiIndex kernel_ndim = (himtx_dev.nrows + sk - 1)/sk;
   	   for(ptiIndex i=1; i < kernel_ndim; i++) {
   		   ptiIndex spawn_block_id = himtx_dev.kschr[i].data[0];
   		   printf(" %d", spawn_block_id);
   		   ARENA_spawn_task(SOLVE, spawn_block_id, spawn_block_id+1, 0);
   	   }
   	   printf("\n");
      }
  }
  return -1;
}

/*
int broadcaset_leftSum_hicoo(int start, int end, int param) {

   ptiIndex row = param;
   printf("rank %d update leftsum %d\n", ARENA_local_rank, row);
 
  
return -1;
}



int Dependent_hicoo(int start, int end, int param) {

   ptiIndex row = param;  
   if (depend_dev.data[row] == 0){
     depend_dev.data[row] = 1;
      printf("rank %d update dependent %d\n", ARENA_local_rank, row);
     //spawn to next node
     ARENA_spawn_task(DEPENDENT, (ARENA_local_end+1)%(total_nb), (ARENA_local_end+1)%(total_nb)+1,row, ARENA_local_rank, row, row+1);
     ARENA_remote_ask_start[(ARENA_local_rank+1)%NODES] = row; //data send to next
     ARENA_remote_ask_end[(ARENA_local_rank+1)%NODES] = row+1;
   }else{
     return -1;
   }
 
  
return -1;
}
*/
       
    
// ----------------------------------------------------------------------
// // Main function. No need to change.
// // ----------------------------------------------------------------------
int main(int argc, char *argv[]) {


    // Initialize global data start and end
  local_rank = ARENA_init(NODES);
  
  //ex: ./spmv webbase-1M.mtx
    int argi = 1;
    
    char  *filename;
    if(argc > argi)
    {
        filename = argv[argi];
        argi++;
    }
    
   data_distribution(filename);
  
  
  local_start = startb_dev;
  local_end   = endb_dev;
  ARENA_set_local(local_start, local_end);

  // Register kernel
  bool isRoot = true;
  int root_start = 0;
  int root_end   = 1;
  int root_param = 0;
  ARENA_register_task(SOLVE, &Solve_hicoo, isRoot, root_start, root_end, root_param);

// Register kernel
  ARENA_register_task(DEPENDENT, &Dependent_hicoo, false); 

// Initialize local allocated data
 // init_data();

    // Execute kernel
   // ARENA_run();
    
    return 0;
}


